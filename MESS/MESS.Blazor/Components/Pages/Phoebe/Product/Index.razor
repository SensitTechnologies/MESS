@page "/products"
@layout PhoebeLayout
@attribute [Authorize(Roles = "Technician, Administrator")]
@using MESS.Blazor.Components.Layout
@using MESS.Data.Models
@using MESS.Services.Product
@using MESS.Services.WorkInstruction
@using Microsoft.AspNetCore.Authorization
@using HorizontalAlignment = MudBlazor.HorizontalAlignment
@using Serilog
@using MESS.Blazor.Components.Pages.Phoebe.Product.ProductTableRow.WorkInstructionAssociation
@using MESS.Blazor.Components.Pages.Phoebe.Product.ProductTableRow
@inject IProductService ProductService
@inject IWorkInstructionService WorkInstructionService
@inject IToastService ToastService

<PageTitle>Product List</PageTitle>

@if (Products.Count == 0)
{
    <h3>Product List</h3>
    <p>No products currently available.</p>
}
else
{
    <div class="d-flex justify-content-between my-2" style="flex-direction: row">
        <h3>Products</h3>
        <div class="flex-grow-1"/>
        <input type="text" class="form-control w-auto" placeholder="Search..."
               @bind="SearchString" @bind:event="oninput"  />
    </div>
    <MudTable @ref="_table"
              T="Product"
              ServerData="ServerReload"
              Loading="IsLoading"
              FixedHeader="true"
              Class="border rounded-3 pt-1"
              TableClass="table table-striped table-hover align-top"
              CellClass="align-top">
        
        <HeaderContent>
            <MudTh><MudTableSortLabel SortLabel="name_field" SortBy="new Func<Product, object>(x => x.Name)"><strong>Name</strong></MudTableSortLabel></MudTh>
            <MudTh><strong>Active</strong></MudTh>
            <MudTh><strong>Work Instruction</strong></MudTh>
            <MudTh><strong>Actions</strong></MudTh>
        </HeaderContent>
        <RowTemplate Context="product">
            <ProductTableRow 
                Product="product" 
                Instructions="_associatedInstructionsMap.ContainsKey(product.Id) 
                    ? _associatedInstructionsMap[product.Id] 
                    : new List<WorkInstruction>()"
                SelectedInstructionIds="GetSelectedIds(product.Id)"
                SelectedInstructionIdsChanged="@GetSelectedIdsChangedCallback(product.Id)"
                OnAddInstructions="@GetAddInstructionsCallback(product.Id)"
                OnRemoveInstructions="@GetRemoveInstructionsCallback(product.Id)"
                OnSubmit="@SubmitProductCallback"
                OnDeleteRequested="@HandleDeleteProductAsync" />
        </RowTemplate>
        <FooterContent>
            <ProductTableRow
                Product="_newProduct"
                Instructions="[]"
                SelectedInstructionIds="[]"
                SelectedInstructionIdsChanged="@NoOpSelectedIdsChangedCallback"
                OnAddInstructions="@EventCallback.Empty"
                OnRemoveInstructions="@NoOpRemoveInstructionsCallback"
                OnSubmit="@SubmitProductCallback"/> 
        </FooterContent>
        <PagerContent>
            <MudTablePager InfoFormat="@InfoFormat()" 
                           HorizontalAlignment="HorizontalAlignment.Center" 
                           RowsPerPageString="Products per Page"/>
        </PagerContent>
    </MudTable>
    
    <AddWorkInstructionDialog 
        Visible="@_addDialogVisible"
        VisibleChanged="@OnVisibleChanged"
        Instructions="@_nonAssociatedInstructions"
        OnAdd="@AddInstructionsCallback" />
}

@code {
    private List<Product> Products { get; set; } = new();
    private Product _newProduct = new() { Name = "", IsActive = true };
    private List<WorkInstruction>? _allInstructions;
    private Dictionary<int, List<int>> SelectedInstructionMap { get; set; } = new();
    private readonly Dictionary<int, EventCallback<List<int>>> _selectedIdsChangedCallbacks = new();
    private Dictionary<int, List<WorkInstruction>> _associatedInstructionsMap = new();

    private bool _addDialogVisible = false;
    private List<WorkInstruction> _nonAssociatedInstructions = [];
    private int CurrentProductId { get; set; }

    private IEnumerable<Product> pagedData = new List<Product>();
    private MudTable<Product> _table = new MudTable<Product>();
    private int _totalTablePages => (_table.GetFilteredItemsCount() / _table.RowsPerPage) + 1;
    private string InfoFormat() => $"Page {_table.CurrentPage + 1} of {_totalTablePages}";
    private int totalItems;
    private bool IsLoading = false;
    private string _searchString = "";
    private String SearchString
    {
        get => _searchString;
        set
        {
            _searchString = value;
            _table.ReloadServerData();
        } 
    }

    /// <summary>
    /// Called by the Blazor framework when the component is initialized.
    /// Loads products and associated instructions.
    /// </summary>
    protected override async Task OnInitializedAsync()
    {
        await GrabServerData();
    }

    private async Task GrabServerData()
    {
        IsLoading = true;
        await LoadProducts();
        _allInstructions = await WorkInstructionService.GetAllLatestAsync();
        RebuildInstructionMap();
        IsLoading = false;
    }

    private async Task<TableData<Product>> ServerReload(TableState state, CancellationToken token)
    {
        IEnumerable<Product> data = Products;
        await Task.Delay(20, token);
        
        
        data = data.Where(product => 
            SatisfiesFilter(product.Name, SearchString)
        ).ToArray();
        totalItems = data.Count();

        switch (state.SortLabel)
        {
            case "name_field":
                data = data.OrderByDirection(state.SortDirection, o => o.Name);
                break;
        }

        pagedData = data.Skip(state.Page * state.PageSize).Take(state.PageSize).ToArray();
        return new TableData<Product>() {TotalItems = totalItems, Items = pagedData};
    }
    
    private bool SatisfiesFilter(string? columnPhrase, string searchPhrase)
    {
        if (!string.IsNullOrWhiteSpace(columnPhrase))
        {
            var trimmedColumnPhrase = columnPhrase.Trim();
            
            // intended for columns to catch smaller search phrases
            if (trimmedColumnPhrase.Contains(searchPhrase, StringComparison.OrdinalIgnoreCase))
                return true;
    
            // for multi worded search phrase
            foreach (var columnPhraseWord in trimmedColumnPhrase.Split(" "))
            {
                foreach (var searchPhraseWord in searchPhrase.Split(" "))
                {
                    if (!string.IsNullOrWhiteSpace(searchPhraseWord) && 
                        (searchPhrase.Contains(columnPhraseWord, StringComparison.OrdinalIgnoreCase)
                         || columnPhrase.Contains(searchPhraseWord, StringComparison.OrdinalIgnoreCase)))
                        return true;
                }
            }
        }

        return false;
    }

    private async Task LoadProducts()
    {
        _newProduct = new Product() { Name = "", IsActive = true };
        Products = (await ProductService.GetAllAsync()).ToList();
    }

    private async Task HandleSubmitProduct(Product product)
    {
        try
        {
            Log.Information("Submitting product: {ProductName} (ID: {ProductId})", product.Name, product.Id);

            if (product.Id == 0)
            {
                await ProductService.CreateAsync(product);
                ToastService.ShowSuccess($"Product '{product.Name}' created successfully!");
            }
            else
            {
                await ProductService.UpdateProductAsync(product);
                ToastService.ShowSuccess($"Product '{product.Name}' updated successfully!");
            }
            await GrabServerData();
            await _table.ReloadServerData();

            Log.Information("Product submitted successfully: {ProductName} (ID: {ProductId})", product.Name, product.Id);
        }
        catch (Exception ex)
        {
            Log.Error(ex, "Error occurred while submitting product: {ProductName} (ID: {ProductId})", product.Name, product.Id);
            ToastService.ShowError($"Error submitting product '{product.Name}'. Please try again.");
        }
    }
    
    private void RebuildInstructionMap()
    {
        if (_allInstructions is null || Products is null) return;

        _associatedInstructionsMap = Products.ToDictionary(
            p => p.Id,
            p => _allInstructions
                .Where(wi => wi.Products.Any(prod => prod.Id == p.Id))
                .ToList()
        );
    }

    private List<int> GetSelectedIds(int productId)
    {
        if (!SelectedInstructionMap.TryGetValue(productId, out var selected))
            selected = [];

        return selected;
    }

    private Task HandleSelectedInstructionIdsChanged(int productId, List<int> selectedIds)
    {
        SelectedInstructionMap[productId] = selectedIds;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private EventCallback<List<int>> GetSelectedIdsChangedCallback(int productId)
    {
        if (!_selectedIdsChangedCallbacks.TryGetValue(productId, out var callback))
        {
            callback = EventCallback.Factory.Create<List<int>>(this,
                (List<int> selectedIds) => HandleSelectedInstructionIdsChanged(productId, selectedIds));
            _selectedIdsChangedCallbacks[productId] = callback;
        }
        return callback;
    }

    private EventCallback GetAddInstructionsCallback(int productId)
    {
        return EventCallback.Factory.Create(this, () => ShowAddDialog(productId));
    }

    private EventCallback<List<int>> GetRemoveInstructionsCallback(int productId)
    {
        return EventCallback.Factory.Create<List<int>>(this,
            (List<int> ids) => RemoveInstructionsFromProduct(productId, ids));
    }

    private EventCallback<Product> SubmitProductCallback =>
        EventCallback.Factory.Create<Product>(this, HandleSubmitProduct);

    private EventCallback<List<int>> NoOpSelectedIdsChangedCallback =>
        EventCallback.Factory.Create<List<int>>(this, _ => Task.CompletedTask);

    private EventCallback<List<int>> NoOpRemoveInstructionsCallback =>
        EventCallback.Factory.Create<List<int>>(this, _ => Task.CompletedTask);

    private EventCallback<List<int>> AddInstructionsCallback =>
        EventCallback.Factory.Create<List<int>>(this, OnAddInstructions);

    private void ShowAddDialog(int productId)
    {
        if (_allInstructions is null)
        {
            ToastService.ShowError("Instructions not loaded yet.");
            return;
        }

        _addDialogVisible = true;
        _nonAssociatedInstructions = _allInstructions
            .Where(wi => wi.Products.All(p => p.Id != productId))
            .ToList();

        CurrentProductId = productId;
    }

    private void OnVisibleChanged(bool visible)
    {
        _addDialogVisible = visible;
    }

    private Task OnAddInstructions(List<int> instructionIds)
    {
        return AssociateInstructionsToProduct(CurrentProductId, instructionIds);
    }

    private async Task AssociateInstructionsToProduct(int productId, List<int> instructionIds)
    {
        await ProductService.AddWorkInstructionsAsync(productId, instructionIds);
        SelectedInstructionMap[productId] = [];
        await GrabServerData();
        await _table.ReloadServerData();
        ToastService.ShowSuccess("Work instructions added.");
    }

    private async Task RemoveInstructionsFromProduct(int productId, List<int> instructionIds)
    {
        await ProductService.RemoveWorkInstructionsAsync(productId, instructionIds);
        SelectedInstructionMap[productId] = [];
        await GrabServerData();
        await _table.ReloadServerData();
        ToastService.ShowSuccess("Selected work instructions removed.");
    }
    
    private async Task HandleDeleteProductAsync(Product product)
    {
        try
        {
            await ProductService.DeleteByIdAsync(product.Id);
            Products.Remove(product);
            _associatedInstructionsMap.Remove(product.Id);
            SelectedInstructionMap.Remove(product.Id);
            _selectedIdsChangedCallbacks.Remove(product.Id);
            
            ToastService.ShowSuccess($"Product '{product.Name}' was deleted.");
            await GrabServerData();
            await _table.ReloadServerData();

        }
        catch (Exception ex)
        {
            Log.Error(ex, "Error deleting product: {ProductName} (ID: {ProductId})", product.Name, product.Id);
            ToastService.ShowError($"Failed to delete '{product.Name}'.");
        }
    }
}
