@namespace MESS.Blazor.Components.Pages.Phoebe.MenuBar 
@using Microsoft.AspNetCore.Components.Authorization
@using MESS.Data.Models
@using MESS.Blazor.Components.Pages.Phoebe.WorkInstruction
@inject AuthenticationStateProvider AuthProvider
@inject ILogger<MenuBarPhoebe> DemoLogger
@inject IJSRuntime JS

<div class="menu-bar-card">
    <button class="btn-small" title="Toggle Sidebar" @onclick="ToggleSidebar" aria-label="Toggle sidebar">☰</button>

    <div class="menu-left-buttons">
        <button class="btn-small" @onclick="ToggleFileMenu" id="btnOpen1" aria-expanded="@open">File</button>
        <FluentMenu Anchor="btnOpen1" Open="@open" OpenChanged="@(val => open = val)" OnMenuChange="OnMenuChange" VerticalThreshold="170">
            <FluentMenuItem OnClick="@(() => ShowPopup("New", "You clicked New."))">New</FluentMenuItem>
            <FluentMenuItem OnClick="@(() => LogAndClose("Import"))">Import</FluentMenuItem>
            <FluentMenuItem OnClick="@(() => LogAndClose("Export"))">Export</FluentMenuItem>
            <FluentMenuItem OnClick="@(() => LogAndClose("Save"))">Save</FluentMenuItem>
            <FluentMenuItem OnClick="@(() => ShowPopup("Save As", "You clicked Save As."))">Save As</FluentMenuItem>
            <FluentMenuItem OnClick="@(() => LogAndClose("Delete"))">Delete</FluentMenuItem>
        </FluentMenu>

        <button class="btn-small" @onclick="ToggleOptionsMenu" id="btnOpen2" aria-expanded="@openOptions">Options</button>
        <FluentMenu Anchor="btnOpen2" Open="@openOptions" OpenChanged="@(val => openOptions = val)" OnMenuChange="OnMenuChange" VerticalThreshold="170">
            <FluentMenuItem Checked="@qrChecked" OnClick="@(() => ToggleOption(nameof(qrChecked)))">QR Code</FluentMenuItem>
            <FluentMenuItem Checked="@serialChecked" OnClick="@(() => ToggleOption(nameof(serialChecked)))">Serial Number</FluentMenuItem>
            <FluentMenuItem Checked="@activeChecked" OnClick="@(() => ToggleOption(nameof(activeChecked)))">Active</FluentMenuItem>
        </FluentMenu>
    </div>

    <div class="inputs-container">
        <input type="text" class="menu-input" placeholder="Enter Title Here..." @bind="inputText" @onkeydown="HandleKeyDown" />
        <input type="text" class="menu-input-secondary" placeholder="Version..." @bind="additionalInput" />
    </div>

    <div class="menu-right-content">
        <button class="btn-small" title="Version History" @onclick="ToggleVersionHistorySidebar">⏲</button>
        <button class="btn-small" title="Save">🖫</button>
        <button class="btn-small dark-toggle-btn" title="Dark Mode" @onclick="ToggleDarkMode">@darkModeIcon</button>

        @if (!string.IsNullOrWhiteSpace(ActiveLineOperator))
        {
            <div class="logout-container">
                <span>@ActiveLineOperator</span>
                <form method="post" action="/api/auth/logout" class="logout-form">
                    <button type="submit" class="btn-small" title="Logout">Logout</button>
                </form>
            </div>
        }
    </div>
</div>

<!-- Pass isDarkMode parameter to popup -->
<PopUpMenu @ref="popupRef" IsDarkMode="@isDarkMode" />

<!-- Version History Sidebar Component -->
<VersionHistoryMenu 
    IsOpen="isVersionHistoryOpen" 
    OnToggle="ToggleVersionHistorySidebar" 
    OnRestore="OnVersionHistoryRestore" />

@code {
    private string? ActiveLineOperator { get; set; }

    /// <summary>
    /// Raised when the sidebar toggle button is clicked.
    /// Used by the parent layout to control sidebar visibility.
    /// </summary>
    [Parameter] 
    public EventCallback OnSidebarToggle { get; set; }

    private bool open = false;
    private bool openOptions = false;
    private bool qrChecked = false;
    private bool serialChecked = false;
    private bool activeChecked = false;
    private string inputText = "";
    private string additionalInput = "";
    private string darkModeIcon = "🌙";

    private bool isDarkMode = false; // Tracks current dark mode state

    private List<Product>? Products { get; set; }
    private List<WorkInstruction>? WorkInstructions { get; set; }

    private int selectedProductId = -1;
    private int selectedWorkInstructionId = -1;

    /// <summary>
    /// Reference to the PopUpMenu component used to show notifications.
    /// Set via @ref after render.
    /// </summary>
    private PopUpMenu? popupRef;

    // ** Version History Sidebar Open State **
    private bool isVersionHistoryOpen = false;

    /// <summary>
    /// Asynchronously initializes the component.
    /// Retrieves the authenticated user's identity and sets initial dark mode state.
    /// </summary>
    protected override async Task OnInitializedAsync()
    {
        var state = await AuthProvider.GetAuthenticationStateAsync();
        ActiveLineOperator = state.User.Identity?.Name;

        // Initialize dark mode state on startup
        isDarkMode = await JS.InvokeAsync<bool>("document.body.classList.contains", "dark-mode");
        darkModeIcon = isDarkMode ? "☀️" : "🌙";
    }

    private void ToggleFileMenu() => (open, openOptions) = (!open, false);
    private void ToggleOptionsMenu() => (openOptions, open) = (!openOptions, false);

    private void OnMenuChange(MenuChangeEventArgs args)
    {
        if (args?.Value is not null)
            DemoLogger.LogInformation($"Item '{args.Value}' clicked");
    }

    private void LogAndClose(string item)
    {
        open = false;
        openOptions = false;
        DemoLogger.LogInformation($"Clicked: {item}");
    }

    private void ShowPopup(string title, string message)
    {
        popupRef?.Show(message, title);
        open = false;
        openOptions = false;
        DemoLogger.LogInformation($"Popup triggered: {title}");
    }

    private void ToggleOption(string field)
    {
        switch (field)
        {
            case nameof(qrChecked): qrChecked = !qrChecked; break;
            case nameof(serialChecked): serialChecked = !serialChecked; break;
            case nameof(activeChecked): activeChecked = !activeChecked; break;
        }
        openOptions = false;
        DemoLogger.LogInformation($"Toggled: {field}");
    }

    private void HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(inputText))
        {
            DemoLogger.LogInformation($"Entered: {inputText}");
            inputText = "";
        }
    }

    private async Task ToggleDarkMode()
    {
        // Toggle the dark mode CSS class on body
        await JS.InvokeVoidAsync("document.body.classList.toggle", "dark-mode");

        // Update local state for icon and popup
        isDarkMode = await JS.InvokeAsync<bool>("document.body.classList.contains", "dark-mode");
        darkModeIcon = isDarkMode ? "☀️" : "🌙";

        DemoLogger.LogInformation("Toggled dark mode");
        StateHasChanged();
    }

    private async Task ToggleSidebar()
    {
        if (OnSidebarToggle.HasDelegate)
            await OnSidebarToggle.InvokeAsync(null);
    }

    // ** Toggle Version History Sidebar **
    private void ToggleVersionHistorySidebar()
    {
        isVersionHistoryOpen = !isVersionHistoryOpen;
    }

    // ** Restore action from Version History Sidebar **
    private void OnVersionHistoryRestore()
    {
        DemoLogger.LogInformation("Version history restore clicked.");
        // Add your restore logic here
    }

    private async Task OnProductSelected(int id)
    {
        selectedProductId = id;
        DemoLogger.LogInformation($"Product selected: {id}");
        WorkInstructions = await LoadWorkInstructionsForProduct(id);
        selectedWorkInstructionId = -1;
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnWorkInstructionSelected(int id)
    {
        selectedWorkInstructionId = id;
        DemoLogger.LogInformation($"Work Instruction selected: {id}");
        await InvokeAsync(StateHasChanged);
    }

    private Task<List<WorkInstruction>> LoadWorkInstructionsForProduct(int productId)
    {
        return Task.FromResult(new List<WorkInstruction>());
    }
}
