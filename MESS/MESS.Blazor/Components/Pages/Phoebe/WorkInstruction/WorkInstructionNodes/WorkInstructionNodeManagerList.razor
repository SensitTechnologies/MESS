@using MESS.Blazor.Components.Pages.Phoebe.WorkInstruction.WorkInstructionNodes.SortableList
@using MESS.Data.Models

<SortableList T="WorkInstructionNode"
              Items="WorkInstructionNodes"
              Handle=".drag-handle"
              OnUpdate="OnItemsChanged"
              Context="node">
    <SortableItemTemplate>
        @NodeTemplate(node)
    </SortableItemTemplate>
</SortableList>


@code {
    /// <summary>
    /// Gets or sets the list of work instruction nodes to render and manage in the sortable list.
    /// </summary>
    /// <remarks>
    /// Each <see cref="WorkInstructionNode"/> in the list can represent either a <see cref="PartNode"/> or a <see cref="Step"/>.
    /// This parameter is required and serves as the data source for drag-and-drop reordering,
    /// as well as for displaying and editing the content of the nodes.
    /// /// </remarks>
    [Parameter, EditorRequired]
    public required List<WorkInstructionNode> WorkInstructionNodes { get; set; }
    
    /// <summary>
    /// Event callback that is triggered when *any* of the steps in this list has been changed.
    /// Use this to notify the parent page that the editor state should be marked as dirty.
    /// </summary>
    [Parameter]
    public EventCallback<WorkInstructionNode?> OnChanged { get; set; }
    
    /// <summary>
    /// Event callback triggered when a node is removed from the list.
    /// The removed <see cref="WorkInstructionNode"/> is passed as the argument.
    /// </summary>
    [Parameter]
    public EventCallback<WorkInstructionNode> OnNodeRemoved { get; set; }
    
    /// <summary>
    /// Event callback that is triggered when a New Node needs to be made
    /// Use this to create a new node of a specific node type at a specified index.
    /// </summary>
    [Parameter]
    public EventCallback<(string, int)> OnNewNodeAt { get; set; }

    private Dictionary<Guid, BlazoredTextEditor> EditorRefs { get; set; } = new();
    private Dictionary<Guid, string> ActiveFields { get; set; } = new();

    private RenderFragment<WorkInstructionNode> NodeTemplate => (node) =>
        @<div id="node-@node.Position">
            <div class="d-flex mb-3 border rounded disable-highlight shadow-sm">
                <div class="d-flex align-items-center drag-handle me-2">
                    <i class="bi bi-grip-vertical h3"/>
                    <div class="vr me-2"/>
                </div>
                <div class="flex-grow-1 my-1">
                    @switch (node)
                    {
                        case PartNode partNode:
                            <PartNodeView PartNode="partNode"
                                          OnNodeAction="HandleNodeAction"
                                          OnChanged="() => OnChanged.InvokeAsync(node)"/>
                            break;

                        case Step stepNode:
                            <StepNodeView Step="stepNode"
                                          EditorRefs="EditorRefs"
                                          ActiveFields="ActiveFields"
                                          OnAction="HandleNodeAction"
                                          OnChanged="() => OnChanged.InvokeAsync(node)"/>
                            break;

                        default:
                            <div>Unknown node type: @node.NodeType</div>
                            break;
                    }
                </div>
            </div>
        </div>;

    private async Task OnItemsChanged((int oldIndex, int newIndex) indices)
    {
        var (oldIndex, newIndex) = indices;
        if (oldIndex == newIndex) return;

        await SaveAllEditorsContentAsync();

        var itemToMove = WorkInstructionNodes[oldIndex];
        WorkInstructionNodes.RemoveAt(oldIndex);

        if (newIndex < WorkInstructionNodes.Count)
        {
            WorkInstructionNodes.Insert(newIndex, itemToMove);
        }
        else
        {
            WorkInstructionNodes.Add(itemToMove);
        }

        if (OnChanged.HasDelegate)
        {
            await OnChanged.InvokeAsync();
        }
    }

    private async Task HandleNodeAction((WorkInstructionNode node, string action) actionTuple)
    {
        var (node, action) = actionTuple;
        var index = WorkInstructionNodes.IndexOf(node);
        if (index == -1) return;

        if (action is ("insertBefore" or "insertAfter"))
        {
            if (OnNewNodeAt.HasDelegate)
            {
                switch (action)
                {
                    case "insertBefore":
                        await OnNewNodeAt.InvokeAsync((node is PartNode? "part" : "step" , index));
                        break;
                    case "insertAfter":
                        await OnNewNodeAt.InvokeAsync((node is PartNode? "part" : "step" , index+1));
                        break;
                }
            }
        }
        else
        {
            await SaveAllEditorsContentAsync();
            
            WorkInstructionNodes.Remove(node);

            switch (action)
            {
                case "up":
                    WorkInstructionNodes.Insert(Math.Max(0, index - 1), node);
                    break;
                case "down":
                    WorkInstructionNodes.Insert(Math.Min(WorkInstructionNodes.Count, index + 1), node);
                    break;
                case "top":
                    WorkInstructionNodes.Insert(0, node);
                    break;
                case "bottom":
                    WorkInstructionNodes.Add(node);
                    break;
                case "remove":
                    // already removed above
                    if (OnNodeRemoved.HasDelegate)
                    {
                        await OnNodeRemoved.InvokeAsync(node);
                    }
                    break;
            }
            
            if (OnChanged.HasDelegate)
            {
                await OnChanged.InvokeAsync(node);
            }
        }
    }
    
    /// <summary>
    /// Iterates over all tracked BlazoredTextEditor instances and saves their current HTML content
    /// into the corresponding <see cref="Step"/> objects in <see cref="WorkInstructionNodes"/>.
    /// </summary>
    /// <remarks>
    /// This ensures that any in-progress edits in the rich text editors are persisted
    /// back to the underlying data model before performing actions like saving to the database
    /// or navigating away from the page.
    /// </remarks>
    /// <returns>A task that represents the asynchronous save operation.</returns>
    public async Task SaveAllEditorsContentAsync()
    {
        foreach (var kvp in EditorRefs)
        {
            var stepClientId = kvp.Key;
            var editor = kvp.Value;

            var currentHtml = await editor.GetHTML();

            // Find the node by ClientId
            var node = WorkInstructionNodes.FirstOrDefault(n => n is Step s && s.ClientId == stepClientId);
            if (node is Step step)
            {
                if (ActiveFields.TryGetValue(stepClientId, out var field) && field == "Body")
                    step.DetailedBody = currentHtml;
                else
                    step.Body = currentHtml;
            }
        }
    }
}