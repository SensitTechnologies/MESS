@using System.Diagnostics.CodeAnalysis

@inject IJSRuntime JS

@typeparam T

<div id="@Id" @ref="containerRef">
    @foreach (var item in Items)
    {
        <div @key="item">
            @if (SortableItemTemplate is not null)
            {
                @SortableItemTemplate(item)
            }
        </div>
    }
</div>

@code {

    /// <summary>
    /// The template to render each sortable item.
    /// </summary>
    [Parameter]
    public RenderFragment<T>? SortableItemTemplate { get; set; }

    /// <summary>
    /// The list of items to display and allow reordering.
    /// </summary>
    [Parameter, AllowNull]
    public List<T> Items { get; set; }

    /// <summary>
    /// Callback invoked when the list is reordered, providing the old and new indices.
    /// </summary>
    [Parameter]
    public EventCallback<(int oldIndex, int newIndex)> OnUpdate { get; set; }

    /// <summary>
    /// Callback invoked when an item is removed from the list.
    /// </summary>
    [Parameter]
    public EventCallback<(int oldIndex, int newIndex)> OnRemove { get; set; }

    /// <summary>
    /// The HTML ID of the list container. Used for targeting in JS interop.
    /// </summary>
    [Parameter]
    public string Id { get; set; } = Guid.NewGuid().ToString();

    /// <summary>
    /// Group name for SortableJS grouping. Allows connected lists to share drag-and-drop.
    /// </summary>
    [Parameter]
    public string Group { get; set; } = Guid.NewGuid().ToString();

    /// <summary>
    /// Defines which other lists items can be pulled from (or null for none).
    /// </summary>
    [Parameter]
    public string? Pull { get; set; }

    /// <summary>
    /// Whether this list accepts items being put into it from other lists.
    /// </summary>
    [Parameter]
    public bool Put { get; set; } = true;

    /// <summary>
    /// Whether the list itself is sortable.
    /// </summary>
    [Parameter]
    public bool Sort { get; set; } = true;

    /// <summary>
    /// CSS selector for the drag handle within each item.
    /// </summary>
    [Parameter]
    public string Handle { get; set; } = string.Empty;

    /// <summary>
    /// CSS selector to filter out non-draggable elements.
    /// </summary>
    [Parameter]
    public string? Filter { get; set; }

    /// <summary>
    /// Whether to force fallback behavior for dragging (for older browsers or custom styling).
    /// </summary>
    [Parameter]
    public bool ForceFallback { get; set; } = true;

    private DotNetObjectReference<SortableList<T>>? selfReference;
    private ElementReference containerRef;
    private IJSObjectReference? moduleRef;
    private bool initialized = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!initialized)
        {
            try
            {
                selfReference = DotNetObjectReference.Create(this);
                moduleRef = await JS.InvokeAsync<IJSObjectReference>("import", "/SortableList.js");

                // Pass the ElementReference so JS receives the actual element (preferred).
                await moduleRef.InvokeVoidAsync("init", containerRef, Group, Pull, Put, Sort, Handle, Filter, selfReference, ForceFallback);
                initialized = true;
            }
            catch (JSException jsEx)
            {
                // defensive: log or handle and avoid crashing the circuit
                Console.Error.WriteLine($"SortableList init failed: {jsEx.Message}");
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"SortableList unexpected init error: {ex}");
            }
        }
    }

    [JSInvokable]
    public Task OnUpdateJS(int oldIndex, int newIndex)
        => OnUpdate.InvokeAsync((oldIndex, newIndex));

    [JSInvokable]
    public Task OnRemoveJS(int oldIndex, int newIndex)
        => OnRemove.InvokeAsync((oldIndex, newIndex));

    // Implement IAsyncDisposable to clean up the JS module and DotNetObjectReference.
    public async ValueTask DisposeAsync()
    {
        try
        {
            if (moduleRef is not null)
            {
                // call destroy to remove Sortable instance on JS side
                try { await moduleRef.InvokeVoidAsync("destroy", containerRef); } catch { /* ignore */ }
                await moduleRef.DisposeAsync();
            }
        }
        catch (Exception e)
        {
            Console.Error.WriteLine($"Error disposing SortableList module: {e}");
        }
        finally
        {
            selfReference?.Dispose();
            selfReference = null;
        }
    }
}