@using MESS.Data.Models
@using MESS.Blazor.Components.Pages.Phoebe.WorkInstruction.SortableList
@using Blazored.TextEditor
@inject IJSRuntime JSRuntime

<SortableList T="WorkInstructionNode"
              Items="WorkInstructionNodes"
              OnUpdate="OnItemsChanged"
              Context="node">
    <SortableItemTemplate>
        @NodeTemplate(node)
    </SortableItemTemplate>
</SortableList>

@code {
    /// <summary>
    /// Gets or sets the list of work instruction nodes to render and manage in the sortable list.
    /// </summary>
    /// <remarks>
    /// Each <see cref="WorkInstructionNode"/> in the list can represent either a <see cref="PartNode"/> or a <see cref="Step"/>.
    /// This parameter is required and serves as the data source for drag-and-drop reordering,
    /// as well as for displaying and editing the content of the nodes.
    /// /// </remarks>
    [Parameter, EditorRequired]
    public required List<WorkInstructionNode> WorkInstructionNodes { get; set; }

    private Dictionary<int, BlazoredTextEditor> EditorRefs { get; set; } = new();
    private Dictionary<int, string> ActiveFields { get; set; } = new();

    private RenderFragment<WorkInstructionNode> NodeTemplate => (node) =>
    @<div class="mb-3 p-3 border rounded">
        <div class="d-flex align-items-center">
            <div class="position me-3">
                <strong>@node.Position</strong>
            </div>
            <div class="type me-3">
                <span>@node.NodeType</span>
            </div>
            <div class="content flex-grow-1">
                @switch (node)
                {
                    case PartNode partNode:
                        <PartNodeView PartNode="partNode" />
                        break;

                    case Step stepNode:
                        <StepNodeView
                            Step="stepNode"
                            EditorRefs="EditorRefs"
                            ActiveFields="ActiveFields"
                            OnAction="HandleStepNodeAction" />
                        break;

                    default:
                        <div>Unknown node type: @node.NodeType</div>
                        break;
                }
            </div>
        </div>
    </div>;
    
    private async Task OnItemsChanged((int oldIndex, int newIndex) indices)
    {
        var (oldIndex, newIndex) = indices;
        if (oldIndex == newIndex) return;

        await SaveAllEditorsContentAsync();

        var itemToMove = WorkInstructionNodes[oldIndex];
        WorkInstructionNodes.RemoveAt(oldIndex);

        if (newIndex < WorkInstructionNodes.Count)
        {
            WorkInstructionNodes.Insert(newIndex, itemToMove);
        }
        else
        {
            WorkInstructionNodes.Add(itemToMove);
        }

        RecalculatePositions();
    }
    
    private void RecalculatePositions()
    {
        for (var i = 0; i < WorkInstructionNodes.Count; i++)
        {
            WorkInstructionNodes[i].Position = i;
        }
    }
    
    private async Task HandleStepNodeAction((Step step, string action) actionTuple)
    {
        var (step, action) = actionTuple;
        var index = WorkInstructionNodes.IndexOf(step);
        if (index == -1) return;

        // Only save if moving or removing
        if (action is not ("insertBefore" or "insertAfter"))
        {
            await SaveAllEditorsContentAsync();
        }

        WorkInstructionNodes.Remove(step);

        switch (action)
        {
            case "up":
                WorkInstructionNodes.Insert(Math.Max(0, index - 1), step);
                break;
            case "down":
                WorkInstructionNodes.Insert(Math.Min(WorkInstructionNodes.Count, index + 1), step);
                break;
            case "top":
                WorkInstructionNodes.Insert(0, step);
                break;
            case "bottom":
                WorkInstructionNodes.Add(step);
                break;
            case "insertBefore":
                WorkInstructionNodes.Insert(index, new Step { Name = "", Body = "" }); // new step at index
                WorkInstructionNodes.Insert(index + 1, step);                        // original step after
                break;
            case "insertAfter":
                WorkInstructionNodes.Insert(index, step);                            // original step at index
                WorkInstructionNodes.Insert(index + 1, new Step { Name = "", Body = "" }); // new step after
                break;
            case "remove":
                // already removed above
                break;
        }

        RecalculatePositions();
    }
    
    /// <summary>
    /// Iterates over all tracked BlazoredTextEditor instances and saves their current HTML content
    /// into the corresponding <see cref="Step"/> objects in <see cref="WorkInstructionNodes"/>.
    /// </summary>
    /// <remarks>
    /// This ensures that any in-progress edits in the rich text editors are persisted
    /// back to the underlying data model before performing actions like saving to the database
    /// or navigating away from the page.
    /// </remarks>
    /// <returns>A task that represents the asynchronous save operation.</returns>
    public async Task SaveAllEditorsContentAsync()
    {
        foreach (var kvp in EditorRefs)
        {
            var stepId = kvp.Key;
            var editor = kvp.Value;
            if (editor == null) continue;

            var currentHtml = await editor.GetHTML();

            // Find the node, check if Step (only steps have editable content)
            var node = WorkInstructionNodes.FirstOrDefault(n => n.Id == stepId);
            if (node is Step step)
            {
                if (ActiveFields.TryGetValue(stepId, out var field) && field == "Body")
                    step.Body = currentHtml;
                else
                    step.Name = currentHtml;
            }
        }
    }
}