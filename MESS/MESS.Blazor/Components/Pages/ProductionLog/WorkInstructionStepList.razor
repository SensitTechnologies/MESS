@using MESS.Data.Models
@using MESS.Blazor.Components.Pages.ProductionLog.WorkInstructionNodes
@using PartNode = MESS.Data.Models.PartNode
@using MESS.Blazor.Components.Pages.ProductionLog.WorkInstructionNodes.PartNode
@using MESS.Services.DTOs.ProductionLogs.Form
@using MESS.Services.DTOs.ProductionLogs.LogSteps.Form
@using MESS.Services.UI.ProductionLogEvent
@inject IProductionLogEventService ProductionLogEventService

@if (ProductionLogs.Any())
{
    <ul class="step">
        @foreach (var block in NodeBlocks)
        {
            switch (block)
            {
                case Step step:
                    var logSteps = new List<LogStepFormDTO>();
                    foreach (var log in ProductionLogs)
                    {
                        var existing = log.LogSteps?.FirstOrDefault(ls => ls.WorkInstructionStepId == step.Id);
                        if (existing == null)
                        {
                            existing = new LogStepFormDTO { WorkInstructionStepId = step.Id };
                            log.LogSteps?.Add(existing);
                        }
                        logSteps.Add(existing);
                    }

                    <li class="mb-3">
                        <div id="step-@step.Position">
                            <StepNodeListItem
                                Step="step"
                                LogSteps="logSteps"
                                OnStepCompleted="OnStepCompleted" />
                        </div>
                    </li>
                    break;

                case List<PartNode> partGroup:
                    <li class="mb-3">
                        <PartNodeGroup PartNodes="partGroup" ProductionLogs="ProductionLogs" />
                    </li>
                    break;
            }
        }

        @if (ActiveWorkInstruction.PartProducedIsSerialized)
        {
            <div class="card card-body">
                <div class="mb-2">
                    <div class="form-label">
                        @(ProductionLogs.Count == 1 ? "Product Serial Number" : "Product Serial Numbers")
                    </div>
                </div>

                <div class="d-flex flex-wrap gap-2 justify-content-around align-content-center">
                    @for (var i = 0; i < ProductionLogs.Count; i++)
                    {
                        var log = ProductionLogs[i];
                        <div class="form-floating flex-grow-1" style="min-width: 220px;">
                            @if (ProductionLogs.Count > 1)
                            {
                                <label for=@($"productSerialNumber-{i}") class="form-label subtle-label">
                                    #@(i + 1)
                                </label>
                            }
                        </div>
                    }
                </div>
            </div>
        }
    </ul>
}

@code {
    /// <summary>
    /// The active work instruction being processed.
    /// </summary>
    [Parameter] public required WorkInstruction ActiveWorkInstruction { get; set; }

    /// <summary>
    /// The production logs associated with the current work instruction.
    /// </summary>
    [Parameter] public required List<ProductionLogFormDTO> ProductionLogs { get; set; }

    /// <summary>
    /// Event callback triggered when a step is completed.
    /// The tuple contains the production log step and an optional boolean indicating completion status.
    /// </summary>
    [Parameter] public EventCallback<(List<LogStepFormDTO>, bool?)> OnStepCompleted { get; set; }
    
    /// <summary>
    /// A processed list of "blocks" â€” each block is either a Step node or a group of Part nodes.
    /// </summary>
    private List<object> NodeBlocks { get; set; } = new();

    protected override void OnParametersSet()
    {
        NodeBlocks = GroupNodes(ActiveWorkInstruction.Nodes.OrderBy(n => n.Position).ToList());
    }

    private static List<object> GroupNodes(List<WorkInstructionNode> nodes)
    {
        var result = new List<object>();
        List<PartNode>? currentGroup = null;

        foreach (var node in nodes)
        {
            if (node is PartNode partNode)
            {
                currentGroup ??= [];
                currentGroup.Add(partNode);
            }
            else
            {
                if (currentGroup is not null)
                {
                    result.Add(currentGroup);
                    currentGroup = null;
                }

                if (node is Step step)
                    result.Add(step);
            }
        }

        // Add the final group if the list ended with part nodes
        if (currentGroup is not null)
            result.Add(currentGroup);

        return result;
    }
}