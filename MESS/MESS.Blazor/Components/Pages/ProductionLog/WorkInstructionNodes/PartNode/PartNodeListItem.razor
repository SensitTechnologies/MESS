@using MESS.Data.Models
@using MESS.Services.Serialization
@inject ISerializationService SerializationService

@if (_initialized)
{
    <div class="mb-2">
        <label for="logIndexInput" class="form-label me-2">Log #</label>
        <input type="number"
               id="logIndexInput"
               class="form-control"
               style="max-width: 80px"
               min="1"
               max="@ProductionLogs.Count"
               @bind="SelectedLogNumber"
               @bind:event="oninput"
               @onchange="ReloadPartsForSelectedIndex" />
    </div>
    
    <RequiredPartsList ProductionLogParts="ProductionLogParts" AfterSerialNumberInput="@AfterSerialNumberInput" />
    
}

@code {

    /// <summary>
    /// The part node that contains the parts to be displayed.
    /// This parameter is required.
    /// </summary>
    [Parameter]
    public required PartNode PartNode { get; set; }
    
    /// <summary>
    /// The list of all production logs. Required to access log IDs by index.
    /// </summary>
    [Parameter]
    public required List<ProductionLog> ProductionLogs { get; set; }
    
    private List<ProductionLogPart> ProductionLogParts { get; set; } = [];
    private bool _initialized = false;
    
    private int SelectedLogIndex { get; set; } = 0;

    // This property is 1-based for the UI binding:
    private int SelectedLogNumber
    {
        get => SelectedLogIndex + 1;     // show 1-based to user
        set
        {
            var newIndex = value - 1;     // convert back to 0-based
            if (newIndex < 0)
                newIndex = 0;
            else if (newIndex >= ProductionLogs.Count)
                newIndex = ProductionLogs.Count - 1;
            if (newIndex != SelectedLogIndex)
            {
                SelectedLogIndex = newIndex;
                ReloadPartsForSelectedIndex();
                StateHasChanged();
            }
        }
    }
    
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        SerializationService.PartsReloadRequested += OnPartsReloadRequested;
    }

    private void OnPartsReloadRequested()
    {
        InitializeProductionLogParts();
        ReloadPartsForSelectedIndex();
        InvokeAsync(StateHasChanged);
    }
    
    /// <summary>
    /// Unsubscribes from the <see cref="SerializationService.PartsReloadRequested"/> event
    /// to prevent memory leaks when the component is disposed.
    /// </summary>
    public void Dispose()
    {
        SerializationService.PartsReloadRequested -= OnPartsReloadRequested;
    }

    /// <inheritdoc />
    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);

        if (firstRender)
        {
            _initialized = true;
            ReloadPartsForSelectedIndex(); // load initially
            StateHasChanged();
        }
    }
    
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        InitializeProductionLogParts();
    }
    
    private void InitializeProductionLogParts()
    {
        for (int i = 0; i < ProductionLogs.Count; i++)
        {
            var existing = SerializationService.GetPartsForLogIndex(i);

            // Only add new parts that aren't already present
            var newParts = PartNode.Parts
                .Where(p => !existing.Any(ep => ep.Part?.Id == p.Id))
                .Select(p => new ProductionLogPart { Part = p })
                .ToList();

            if (newParts.Any())
            {
                existing.AddRange(newParts);
                SerializationService.SetPartsForLogIndex(i, existing);
            }
        }
    }

    
    private void ReloadPartsForSelectedIndex()
    {
        if (SelectedLogIndex >= 0 && SelectedLogIndex < ProductionLogs.Count)
        {
            var loaded = SerializationService.GetPartsForLogIndex(SelectedLogIndex);

            // Safety fallback in case it was missed in initialization
            if (loaded.Count == 0)
            {
                loaded = PartNode.Parts
                    .Select(p => new ProductionLogPart { Part = p })
                    .ToList();

                SerializationService.SetPartsForLogIndex(SelectedLogIndex, loaded);
            }

            ProductionLogParts = loaded;
        }
        else
        {
            ProductionLogParts = [];
        }
    }
    
    private void AfterSerialNumberInput(ProductionLogPart updatedPart)
    {
        if (SelectedLogIndex < 0 || SelectedLogIndex >= ProductionLogs.Count)
            return;

        updatedPart.SubmitTimeQc = DateTimeOffset.UtcNow;

        // Update the displayed list first (in-place modification)
        var displayIndex = ProductionLogParts.FindIndex(p => p.Part?.Id == updatedPart.Part?.Id);
        if (displayIndex != -1)
        {
            ProductionLogParts[displayIndex] = updatedPart;
        }

        // Now sync to the serialization service
        var storedParts = SerializationService.GetPartsForLogIndex(SelectedLogIndex);
        var storedIndex = storedParts.FindIndex(p => p.Part?.Id == updatedPart.Part?.Id);
        if (storedIndex != -1)
        {
            storedParts[storedIndex] = updatedPart;
        }
        else
        {
            storedParts.Add(updatedPart);
        }

        SerializationService.SetPartsForLogIndex(SelectedLogIndex, storedParts);
    }

}