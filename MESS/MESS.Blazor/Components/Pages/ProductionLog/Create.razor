@page "/production-log/new"
@page "/production-log/edit/{logId:int}"
@using MESS.Data.Models
@using MESS.Services.BrowserCacheManager
@using MESS.Services.Product
@using MESS.Services.ProductionLog
@using MESS.Services.WorkInstruction
@using Serilog
@using MESS.Blazor.Components.Utility
@inject IProductionLogService ProductionLogService
@inject NavigationManager NavigationManager
@inject IWorkInstructionService WorkInstructionService
@inject IProductService ProductService
@inject ILocalCacheManager LocalCacheManager
@attribute [StreamRendering]

<PageTitle>@Title</PageTitle>
<ErrorBoundary>
    <ChildContent>
        <EditForm FormName="EditProductionLog" Model="ProductionLog" OnValidSubmit="HandleSubmit">
            <DataAnnotationsValidator/>
            <ValidationSummary/>
            <TimeFormValidator TModel="ProductionLog" Validator="_validator"></TimeFormValidator>
            <div class="mb-3">
                
                @if (!IsEditMode)
                {
                    <div>
                        <button @onclick="async _ => await ResetCachedValues()">Reset Configuration</button>
                    </div>
                }

                @if (!InProgress && !IsEditMode)
                {
                    <ProductSelect Products="@Products" OnProductSelected="@SetActiveProduct"/>
                }
                else
                {
                    <CreateHeader ActiveProduct="@ActiveProduct" WorkStation="@WorkStation" LineOperator="@LineOperator"/>
                }

                <WorkInstructionStepList ActiveWorkInstruction="@ActiveWorkInstruction" ProductionLog="ProductionLog" OnStepCompleted="@((args) => OnStepCompleted(args.Item1, args.Item2))" IsEditMode="@IsEditMode"/>

            </div>
            <div class="d-inline-flex justify-content-center gap-4">

                @if (IsEditMode)
                {
                    <div class="d-flex align-items-center form-control">
                        <label for="timePickerSubmit" class="me-2">Submit Time:</label>
                        <div id="timePickerSubmit">
                            <TimePicker @bind-Time="ProductionLog.SubmitTime"
                                        Min="@GetLatestStepTime()" Max="null" CssClass="mb-0"/>
                        </div>
                        
                    </div>
                }

                <div class="text-end align-content-center">
                    <button type="submit" class="btn btn-primary">Save</button>
                    
                </div>
                
                <div>
                    <p>
                        @if (IsSaved)
                        {
                            <span class="text-success">Saved</span>
                        }
                        else
                        {
                            <span class="text-danger">Unsaved</span>
                        }
                    </p>
                </div>
                
            </div>


        </EditForm>
    </ChildContent>
    <ErrorContent Context="ex">
        <div class="alert alert-danger" role="alert">
            An error occurred: @ex.Message
        </div>
    </ErrorContent>
</ErrorBoundary>
@code {
    [Parameter]
    public int? logId { get; set; }
    private bool IsEditMode => logId.HasValue;
    private string Title = "Add";
    private bool InProgress { get; set; }
    
    private string? ActiveProduct { get; set; }
    private string? WorkStation { get; set; }
    private string? LineOperator { get; set; }
    
    protected ProductionLog ProductionLog = new();
    
    private List<Product>? Products { get; set; }
    private WorkInstruction? ActiveWorkInstruction { get; set; }
    private readonly ProductionLogValidator _validator = new();
    private Timer? _debounceTimer;
    private bool IsSaved { get; set; }
    
    protected override async Task OnInitializedAsync()
    {
        await GetInProgressAsync();
        await LoadProducts();
        await LoadProductionLog();
        
        
        var cachedFormData = await LocalCacheManager.GetProductionLogFormAsync();
        if (cachedFormData != null && cachedFormData.LogSteps.Any())
        {
            ProductionLog = new ProductionLog
            {
                LogSteps = cachedFormData.LogSteps.Select(step => new ProductionLogStep
                {
                    WorkInstructionStepId = step.WorkInstructionStepId,
                    Success = step.Success,
                    Notes = step.Notes ?? "",
                    SubmitTime = step.SubmitTime
                }).ToList()
            };
        }
        
        // TO BE REMOVED
        WorkStation = "Primary ABV";
        LineOperator = "John Doe";
    }
    
    private DateTimeOffset? GetLatestStepTime()
    {
        return ProductionLog.LogSteps
            .Where(s => s.SubmitTime != default)
            .Max(s => s.SubmitTime as DateTimeOffset?);
    }

    private async Task SetActiveProduct(int productId)
    {
        try
        {
            if (Products != null)
            {
                var product = Products.FirstOrDefault(p => p.Id == productId);

                if (product?.WorkInstructions == null)
                {
                    return;
                }

                // SETTING ACTIVE WORK INSTRUCTION TO THE FIRST IN THE LIST SINCE WE DO NOT YET KNOW IF THERE WILL BE 
                // AN ACTIVE WORK INSTRUCTION FOR EACH PRODUCT OR A WAY TO ALLOW OPERATORS TO CHOOSE
                await SetSelectedWorkInstructionId(int.Parse(product.WorkInstructions.First().Id.ToString()));
                ActiveProduct = product.Name;

                await LocalCacheManager.SetActiveProductAsync(product);
            }
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
        }
    }
    
    private async Task GetCachedActiveProductAsync()
    {
        var result = await LocalCacheManager.GetActiveProductAsync();
        ActiveProduct = result.Name;
    }

    /// Sets the local storage variable
    private async Task SetInProgressAsync(bool inProgress)
    {
        try
        {
            await LocalCacheManager.SetInProgressAsync(inProgress);
            InProgress = inProgress;
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
        }
    }

    /// If retrieval fails set in progress too false to allow user to restart workflow
    private async Task GetInProgressAsync()
    {
        try
        {
            var result = await LocalCacheManager.GetInProgressAsync();
            
            if (result)
            {
                InProgress = result;
                await GetCachedActiveWorkInstructionAsync();
                await GetCachedActiveProductAsync();
                return;
            }

            await SetInProgressAsync(false);
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
        }
    }
    

    private async Task GetCachedActiveWorkInstructionAsync()
    {
        try
        {
            var result = await LocalCacheManager.GetActiveWorkInstructionIdAsync(); 
            await LoadActiveWorkInstruction(result);
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
        }
    }

    private async Task SetCachedActiveWorkInstructionIdAsync(int workInstructionId)
    {
        await LocalCacheManager.SetActiveWorkInstructionIdAsync(workInstructionId);
    }

    private async Task LoadProducts()
    {
        try
        {
            var productsAsync = await ProductService.GetAllProductsAsync();
            Products = productsAsync.ToList();
        }
        catch (Exception e)
        {
            Log.Error("Error loading work instructions: {Message}", e.Message);
        }
    }
    
    private async Task LoadProductionLog()
    {
        if (logId.HasValue && logId.Value != 0)
        {
            await LoadExistingLog(logId.Value);
        }
    }
    
    
    private async Task SetSelectedWorkInstructionId(int? value)
    {
        try
        {
            if (value.HasValue)
            {
                await LoadActiveWorkInstruction(value.Value);
                await SetCachedActiveWorkInstructionIdAsync(value.Value);
                await SetInProgressAsync(true);
            }
        }
        catch (Exception e)
        {
            Log.Error("Error Setting selected work instruction ID: Exception: {e}", e.Message);
        }

    }


    private async Task LoadActiveWorkInstruction(int id)
    {
        ActiveWorkInstruction = await WorkInstructionService.GetByIdAsync(id);
    }
    
    /// Loads a Production Log from the database
    private async Task LoadExistingLog(int id)
    {
        var existingProductionLog = await ProductionLogService.GetByIdAsync(id);
        if (existingProductionLog != null)
        {
            Title = "Edit";
            ProductionLog = existingProductionLog;

            if (ProductionLog.WorkInstruction != null)
            {
                await SetSelectedWorkInstructionId(ProductionLog.WorkInstruction.Id);
            }
            
        }
        else
        {
            Console.WriteLine($"Production log with ID {id} not found.");
        }
    }

    
    
    protected async Task HandleSubmit()
    {
        if (ActiveWorkInstruction == null)
        {
            Console.WriteLine("No Work Instruction selected.");
            return;
        }

        var currentTime = DateTimeOffset.UtcNow;

        ProductionLog.WorkInstruction = ActiveWorkInstruction;

        if (IsEditMode)
        {
            // Update existing log
            ProductionLog.LastModifiedOn = currentTime;
            await ProductionLogService.UpdateAsync(ProductionLog);
            
            // Navigate to the log list page since there is no need to stay on the edit page since the state is unsaved
            NavigationManager.NavigateTo("/production-log");
        }
        else
        {
            // Create new log
            ProductionLog.CreatedOn = currentTime;
            ProductionLog.LastModifiedOn = currentTime;
            ProductionLog.SubmitTime = currentTime;
            await ProductionLogService.CreateAsync(ProductionLog);
        }

        // Reset the local storage values
        await LocalCacheManager.SetNewProductionLogFormAsync(null);
        NavigationManager.Refresh(true);
    }
    
    private void OnStepCompleted(ProductionLogStep step, bool success)
    {
        var currentTime = DateTimeOffset.UtcNow;
        
        step.Success = success;
        step.SubmitTime = currentTime;

        IsSaved = false;
        
        // Cancel current timer if it exists
        _debounceTimer?.DisposeAsync();
        
        _debounceTimer = new Timer(async _ =>
        {
            // Persist the changes to the local storage
            await LocalCacheManager.SetNewProductionLogFormAsync(ProductionLog);
            
            await InvokeAsync(() =>
            {
                IsSaved = true;
                StateHasChanged();
            });
        }, null, 2000, Timeout.Infinite); // 500ms delay

        StateHasChanged();
    }

    /// Removes the current 'state' from the browsers local storage since they are navigating to a page
    /// which will allow the operator to change product, or workstation, or to view previous session logs
    private async Task ResetCachedValues()
    {
        await LocalCacheManager.ResetCachedValuesAsync();
    }

}